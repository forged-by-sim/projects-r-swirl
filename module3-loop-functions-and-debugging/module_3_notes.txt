Loop Functions - lapply

Looping on the Command Line 
Writing for, while loops is useful when programming but not particularly easy when working interactively on the command line. There are some functions which implement looping to make life easier.
-lappy: Loop over a list and evaluate a function on each element 
-sapply: Same as lapply but try to simplify the result
-apply: Apply a function over the margins of an array
-tapply: Apply a function over subsets of a vector
-mapply: Multivariate version of lapply
An axillary function split is also useful, particularly in conjunction with lapply.

lapply
lapply takes three arguments: (1) a list x; (2) a function (or the name of a function) FUN; (3) other arguments via its ... argument. If x is not a list, it will be coerced to a list using as.list
The actual looping is done internally in C code.
lapply always returns a list, regardless of the class of the input. 
lapply and friends make heavy use of anonymous functions.
An anonymous function for extracting the first column of each matrix. 

sapply
sapply will try to simplify the result of lapply if possible. 
-If the result is a list where every element is length 1, then a vector is returned
-If the result is a list where every element is a vector of the same length (>1), a matrix is returned
-If it can't figure things out, a list is returned






Loop Functions - apply

apply
apply is used to a evaluate a function (often an anonymous one) over the margins of an array
-It is most often used to apply a function to the rows or columns of a matrix 
-It can be used with general arrays, e.g. taking the average of an array of matrices
-It is not really faster than writing a loop, but it works in one line! 
-x is an array
-MARGIN is an integer vector indicating which margins should be "retained"
-FUN is a function to be applied 
-... is for other arguments to be passed to FUN

col/row sums and means 
For sums and means of matrix dimensions, we have some shortcuts
-rowSums = apply(x, 1, sum)
-rowMeans = apply (x, 1 , mean)
-colSums = apply (x, 2, sum)
-colMeans = apply (x, 2, mean) 
The shortcut functions are much faster, but you won't notice unless you're using a large matrix.

Other Ways to Apply
Qualities of the rows of a matrix.

apply
Average matrix in an array






Loop Functions - apply

mapply
mapply is a multivariate apply of sorts which applies a function in parallel over a set of arguments.
-FUN is a function to apply
-... contains arguments to apply other 
-MoreArgs is a list of other arguments to FUN 
-SIMPLIFY indicates whether the result should be simplified 

The following is tedious to type 
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))
Instead we can do
> mapply(rep, 1:4, 4:1) 

Vectorizing a function
Instant Vectorization






Loop Functions - tapply

tapply
tapply is used to apply a function over subsets of a vector. I don't know why it's called tapply.
-x is a vector 
-INDEX is a factor or a list of factors (or else they are coerced to factors)
-FUN is a function to be applied 
-... contains other arguments to be passed FUN
-simplify, should we simplify the result? 

-Take group names.
-Take group means without simplification.
-Find group ranges.






Loop Functions - split 

split
split takes a vector or other objects and splits it into groups determined by a factor or list of factors 
-x is a vector (or list) or data frame 
-f is a factor (or coerced to one) or a list of factors 
-drop indicates whether empty factors levels should be dropped

A common idiom is split followed by an lapply 

Splitting a Data Frame 
Splitting on More than One Level
-Interactions can create empty levels 

split
Empty levels can be dropped. 







Debugging Tools - Diagnosing the Problem 

Something Wrong! 
Indications that something's not right 
-message: A generic notification/diagnostic message produced by the message function; execution of the function continues
-warning: An indication that something is wrong but not necessarily fatal; execution of the function continues; generated by the warning function
-error: An indication that a fatal problem has occurred; execution stops; produced by the stop function
-condition: A generic concept for indicating that something unexpected can occur; programmers can create their own conditions

How do you know that something is wrong with your function? 
-What was your input? How did you call the function?
-What were you expecting? Output, messages, other results?
-What did you get?
-How does what you get differ from what you were expecting?
-Were your expectations correct in the first place?
-Can you reproduce the problem (exactly)? 






Debugging Tools - Basic Tools

Debugging Tools in R
The primary tools for debugging functions in R are
-traceback: prints out the function call stack after an error occurs; does nothing if there's no error
-debug: flags a function for "debug" mode which allows you to step through execution of a function one line at a time
-browser: suspends the execution of a function wherever it is called and puts the function in debug mode
-trace: allows you to insert debugging code into a function a specific places 
-recover: allows you to modify the error behavior so that you can browse the function call stack 
These are interactive tools specifically designed to allow you to pick through a function. There's also the more blunt technique of inserting print/cat statements in the function.






Debugging Tools - Using the Tools

Summary
-There are three main indications of a problem/condition: message, warning, error 
    - only an error is fatal
-When analyzing a function with a problem, make sure you can reproduce the problem, clearly state your expectations and how the output differs from your expectation 
-Interactive debugging tools traceback, debug, browser, trace, and recover can be used to find problematic code in functions 
-Debugging tools are not a substitute for thinking! 
